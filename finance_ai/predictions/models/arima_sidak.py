# -*- coding: utf-8 -*-
"""arima_sidak.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1any8FwUbtOO8yYCfuy2x2SvE1v2T_f3J
"""

!pip install smartapi-python logzero pyotp

from SmartApi import SmartConnect #or from SmartApi.smartConnect import SmartConnect
import pyotp
from logzero import logger

api_key = 'L2Yju3dj'
username = 'S59529465'
pwd = '0503'
smartApi = SmartConnect(api_key)

try:
    token = "RFGIXFS2FGIOEUBETMJPKKSMI4"
    totp = pyotp.TOTP(token).now()
    print("Successful")
except Exception as e:
    logger.error("Invalid Token: The provided token is not valid.")
    raise e

correlation_id = "abcde"
data = smartApi.generateSession(username, pwd, totp)


if data['status'] == False:
    logger.error(data)

else:
    # login api call
    # logger.info(f"You Credentials: {data}")
    authToken = data['data']['jwtToken']
    refreshToken = data['data']['refreshToken']
    # fetch the feedtoken
    feedToken = smartApi.getfeedToken()
    # fetch User Profile
    res = smartApi.getProfile(refreshToken)
    smartApi.generateToken(refreshToken)
    res=res['data']['exchanges']

from datetime import datetime

# Get the current date and time
now = datetime.now()

# Format it as "YYYY-MM-DD HH:MM"
current_formatted_datetime = now.strftime("%Y-%m-%d %H:%M")

print(current_formatted_datetime)

"""#testing"""

try:
        current_formatted_datetime = datetime.now().strftime("%Y-%m-%d %H:%M")
        historicParam={
        "exchange": "NSE",
        "symboltoken": "2885", # reliance
        "interval": "ONE_DAY",
        "fromdate": "2023-01-01 15:30", #end day time manual convert this to automatic
        "todate": current_formatted_datetime
        }
        data=smartApi.getCandleData(historicParam)
except Exception as e:
        logger.exception(f"Historic Api failed: {e}")

data['data']

import pandas as pd

df = pd.DataFrame(data['data'],columns=["Date Time","Open","High","Low","Close","Volume"])

df

"""# Getting actual data of multiple stocks"""



# Initialize an empty master DataFrame
master_df = pd.DataFrame()

# List of stock tokens and their respective names
stock_list = [
    {"symboltoken": "2885", "stock_name": "RELIANCE"},
    {"symboltoken": "3045", "stock_name": "TCS"}
    # {"symboltoken": "1594", "stock_name": "INFY"},
    # {"symboltoken": "11536", "stock_name": "HDFC"},
    # {"symboltoken": "1333", "stock_name": "ICICIBANK"},
    # {"symboltoken": "25", "stock_name": "SBIN"},
    # {"symboltoken": "4717", "stock_name": "HDFCBANK"},
    # {"symboltoken": "20374", "stock_name": "BHARTIARTL"},
    # {"symboltoken": "3456", "stock_name": "WIPRO"},
    # {"symboltoken": "700", "stock_name": "LT"},
]

# Get current date-time in required format
current_formatted_datetime = datetime.now().strftime("%Y-%m-%d %H:%M")

# Loop through each stock and fetch data
for stock in stock_list:
    try:
        historicParam = {
            "exchange": "NSE",
            "symboltoken": stock["symboltoken"],
            "interval": "ONE_DAY",
            "fromdate": "2023-01-01 15:30",  # Static, modify if needed
            "todate": current_formatted_datetime,
        }

        # Fetch data from API
        data = smartApi.getCandleData(historicParam)

        # Convert data to DataFrame
        df = pd.DataFrame(data['data'], columns=["Date Time", "Open", "High", "Low", "Close", "Volume"])

        # Add stock symbol column
        df["Stock Symbol"] = stock["stock_name"]

        # Append to master DataFrame
        master_df = pd.concat([master_df, df], ignore_index=True)

    except Exception as e:
        logger.exception(f"Historic API failed for {stock['stock_name']}: {e}")

# print(type(master_df))

master_df

"""# Connection with mysql

status : Pending
"""

df_to_upload = master_df.rename(columns={
    "Date Time": "Date",
    "Stock Symbol": "Stock_Name"
})

df_to_upload

df_to_upload.dtypes

reliance_data = df_to_upload[df_to_upload["Stock_Name"] == "RELIANCE"]

tcs_data = df_to_upload[df_to_upload["Stock_Name"] == "TCS"]

tcs_data

pd.to_datetime(tcs_data['Date'])



reliance_data





reliance_data['Date'] = pd.to_datetime(reliance_data['Date'])
reliance_data.set_index('Date', inplace=True)
price_series = reliance_data['Close']

reliance_data

"""# Arima Model"""



"""Step 2: Check Stationarity

Use the Augmented Dickey-Fuller (ADF) test:
"""

from statsmodels.tsa.stattools import adfuller

adf_result = adfuller(price_series)
print(f"ADF Statistic: {adf_result[0]}, p-value: {adf_result[1]}")
# If p-value > 0.05, apply differencing (d=1)



"""Step 3: Find Optimal (p, d, q)

Use AutoARIMA to automate parameter selection:
"""

!pip install pmdarima

from pmdarima import auto_arima

model = auto_arima(
    price_series,
    seasonal=False,  # For non-seasonal ARIMA
    trace=True,
    error_action='ignore',
    suppress_warnings=True
)
print(model.order)  # (p, d, q)

from statsmodels.tsa.arima.model import ARIMA

p, d, q = (15, 2, 1)  # Example from auto_arima, p value we have taken long because we want last p days to predict the next day value........
model = ARIMA(price_series, order=(p, d, q))
fitted_model = model.fit()
print(fitted_model.summary())

import matplotlib.pyplot as plt

print(reliance_data.index.min(), reliance_data.index.max()) # just for checking

# Generate new forecast after fixing issues
forecast = fitted_model.get_forecast(steps=7)
mean_forecast = forecast.predicted_mean
confidence_intervals = forecast.conf_int()

# Assign proper date index
forecast_dates = pd.date_range(start=reliance_data.index[-1], periods=8, freq='D')[1:]
mean_forecast.index = forecast_dates
confidence_intervals.index = forecast_dates

# Plot again
plt.figure(figsize=(10, 6))
plt.plot(reliance_data['Close'], label='Historical Data')
plt.plot(mean_forecast.index, mean_forecast, color='red', label='Forecast')
plt.fill_between(confidence_intervals.index, confidence_intervals.iloc[:, 0], confidence_intervals.iloc[:, 1], color='pink', alpha=0.3)
plt.legend()
plt.show()

